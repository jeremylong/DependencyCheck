<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>YarnAuditAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dependency-Check Core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">YarnAuditAnalyzer.java</span></div><h1>YarnAuditAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-ant.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2021 The OWASP Foundation. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.annotation.concurrent.ThreadSafe;
import javax.json.Json;
import javax.json.JsonException;
import javax.json.JsonObject;
import javax.json.JsonReader;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.analyzer.exception.SearchException;
import org.owasp.dependencycheck.analyzer.exception.UnexpectedAnalysisException;
import org.owasp.dependencycheck.data.nodeaudit.Advisory;
import org.owasp.dependencycheck.data.nodeaudit.NpmPayloadBuilder;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.exception.InitializationException;
import org.owasp.dependencycheck.utils.FileFilterBuilder;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.utils.URLConnectionFailureException;
import org.owasp.dependencycheck.utils.processing.ProcessReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.parsers.cpe.exceptions.CpeValidationException;

@ThreadSafe
<span class="fc" id="L56">public class YarnAuditAnalyzer extends AbstractNpmAnalyzer {</span>

    /**
     * The logger.
     */
<span class="fc" id="L61">    private static final Logger LOGGER = LoggerFactory.getLogger(YarnAuditAnalyzer.class);</span>

    /**
     * The file name to scan.
     */
    public static final String YARN_PACKAGE_LOCK = &quot;yarn.lock&quot;;

    /**
     * Filter that detects files named &quot;yarn.lock&quot;
     */
<span class="fc" id="L71">    private static final FileFilter LOCK_FILE_FILTER = FileFilterBuilder.newInstance()</span>
<span class="fc" id="L72">            .addFilenames(YARN_PACKAGE_LOCK).build();</span>

    /**
     * An expected error from `yarn audit --offline --verbose --json` that will
     * be ignored.
     */
    private static final String EXPECTED_ERROR = &quot;{\&quot;type\&quot;:\&quot;error\&quot;,\&quot;data\&quot;:\&quot;Can't make a request in &quot;
            + &quot;offline mode (\\\&quot;https://registry.yarnpkg.com/-/npm/v1/security/audits\\\&quot;)\&quot;}\n&quot;;

    /**
     * The path to the `yarn` executable.
     */
    private String yarnPath;

    /**
     * Analyzes the yarn lock file to determine vulnerable dependencies. Uses
     * yarn audit --offline to generate the payload to be sent to the NPM API.
     *
     * @param dependency the yarn lock file
     * @param engine the analysis engine
     * @throws AnalysisException thrown if there is an error analyzing the file
     */
    @Override
    protected void analyzeDependency(Dependency dependency, Engine engine) throws AnalysisException {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (dependency.getDisplayFileName().equals(dependency.getFileName())) {</span>
<span class="fc" id="L97">            engine.removeDependency(dependency);</span>
        }
<span class="fc" id="L99">        final File packageLock = dependency.getActualFile();</span>
<span class="pc bpc" id="L100" title="3 of 6 branches missed.">        if (!packageLock.isFile() || packageLock.length() == 0 || !shouldProcess(packageLock)) {</span>
<span class="nc" id="L101">            return;</span>
        }
<span class="fc" id="L103">        final File packageJson = new File(packageLock.getParentFile(), &quot;package.json&quot;);</span>
        final List&lt;Advisory&gt; advisories;
<span class="fc" id="L105">        final MultiValuedMap&lt;String, String&gt; dependencyMap = new HashSetValuedHashMap&lt;&gt;();</span>
<span class="fc" id="L106">        advisories = analyzePackage(packageLock, packageJson, dependency, dependencyMap);</span>
        try {
<span class="fc" id="L108">            processResults(advisories, engine, dependency, dependencyMap);</span>
<span class="nc" id="L109">        } catch (CpeValidationException ex) {</span>
<span class="nc" id="L110">            throw new UnexpectedAnalysisException(ex);</span>
<span class="fc" id="L111">        }</span>
<span class="fc" id="L112">    }</span>

    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L116">        return Settings.KEYS.ANALYZER_YARN_AUDIT_ENABLED;</span>
    }

    @Override
    protected FileFilter getFileFilter() {
<span class="fc" id="L121">        return LOCK_FILE_FILTER;</span>
    }

    @Override
    public String getName() {
<span class="fc" id="L126">        return &quot;Yarn Audit Analyzer&quot;;</span>
    }

    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L131">        return AnalysisPhase.FINDING_ANALYSIS;</span>
    }

    /**
     * Initializes the analyzer once before any analysis is performed.
     *
     * @param engine a reference to the dependency-check engine
     * @throws InitializationException if there's an error during initialization
     */
    @Override
    protected void prepareFileTypeAnalyzer(Engine engine) throws InitializationException {
<span class="fc" id="L142">        super.prepareFileTypeAnalyzer(engine);</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (!isEnabled()) {</span>
<span class="nc" id="L144">            LOGGER.debug(&quot;{} Analyzer is disabled skipping yarn executable check&quot;, getName());</span>
<span class="nc" id="L145">            return;</span>
        }
<span class="fc" id="L147">        final List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L148">        args.add(getYarn());</span>
<span class="fc" id="L149">        args.add(&quot;--help&quot;);</span>
<span class="fc" id="L150">        final ProcessBuilder builder = new ProcessBuilder(args);</span>
<span class="fc" id="L151">        LOGGER.debug(&quot;Launching: {}&quot;, args);</span>
        try {
<span class="fc" id="L153">            final Process process = builder.start();</span>
<span class="fc" id="L154">            try (ProcessReader processReader = new ProcessReader(process)) {</span>
<span class="fc" id="L155">                processReader.readAll();</span>
<span class="fc" id="L156">                final int exitValue = process.waitFor();</span>
<span class="fc" id="L157">                final int expectedExitValue = 0;</span>
<span class="fc" id="L158">                final int yarnExecutableNotFoundExitValue = 127;</span>
<span class="pc bpc" id="L159" title="2 of 3 branches missed.">                switch (exitValue) {</span>
                    case expectedExitValue:
<span class="fc" id="L161">                        LOGGER.debug(&quot;{} is enabled.&quot;, getName());</span>
<span class="fc" id="L162">                        break;</span>
                    case yarnExecutableNotFoundExitValue:
<span class="nc" id="L164">                        this.setEnabled(false);</span>
<span class="nc" id="L165">                        LOGGER.warn(&quot;The {} has been disabled. Yarn executable was not found.&quot;, getName());</span>
                    default:
<span class="nc" id="L167">                        this.setEnabled(false);</span>
<span class="nc" id="L168">                        LOGGER.warn(&quot;The {} has been disabled. Yarn executable was not found.&quot;, getName());</span>
                }
            }
<span class="nc" id="L171">        } catch (Exception ex) {</span>
<span class="nc" id="L172">            this.setEnabled(false);</span>
<span class="nc" id="L173">            LOGGER.debug(&quot;The {} has been disabled. Yarn executable was not found.&quot;, ex);</span>
<span class="nc" id="L174">            LOGGER.warn(&quot;The {} has been disabled. Yarn executable was not found.&quot;, getName());</span>
<span class="nc" id="L175">            throw new InitializationException(&quot;Unable to read yarn audit output.&quot;, ex);</span>
<span class="fc" id="L176">        }</span>
<span class="fc" id="L177">    }</span>

    /**
     * Attempts to determine the path to `yarn`.
     *
     * @return the path to `yarn`
     */
    private String getYarn() {
        final String value;
<span class="fc" id="L186">        synchronized (this) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (yarnPath == null) {</span>
<span class="fc" id="L188">                final String path = getSettings().getString(Settings.KEYS.ANALYZER_YARN_PATH);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">                if (path == null) {</span>
<span class="fc" id="L190">                    yarnPath = &quot;yarn&quot;;</span>
                } else {
<span class="nc" id="L192">                    final File yarnFile = new File(path);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    if (yarnFile.isFile()) {</span>
<span class="nc" id="L194">                        yarnPath = yarnFile.getAbsolutePath();</span>
                    } else {
<span class="nc" id="L196">                        LOGGER.warn(&quot;Provided path to `yarn` executable is invalid.&quot;);</span>
<span class="nc" id="L197">                        yarnPath = &quot;yarn&quot;;</span>
                    }
                }
            }
<span class="fc" id="L201">            value = yarnPath;</span>
<span class="fc" id="L202">        }</span>
<span class="fc" id="L203">        return value;</span>
    }

    private JsonObject fetchYarnAuditJson(Dependency dependency, boolean skipDevDependencies) throws AnalysisException {
<span class="fc" id="L207">        final File folder = dependency.getActualFile().getParentFile();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (!folder.isDirectory()) {</span>
<span class="nc" id="L209">            throw new AnalysisException(String.format(&quot;%s should have been a directory.&quot;, folder.getAbsolutePath()));</span>
        }
        try {
<span class="fc" id="L212">            final List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L214">            args.add(getYarn());</span>
<span class="fc" id="L215">            args.add(&quot;audit&quot;);</span>
            //offline audit is not supported - but the audit request is generated in the verbose output
<span class="fc" id="L217">            args.add(&quot;--offline&quot;);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (skipDevDependencies) {</span>
<span class="nc" id="L219">                args.add(&quot;--groups&quot;);</span>
<span class="nc" id="L220">                args.add(&quot;dependencies&quot;);</span>
            }
<span class="fc" id="L222">            args.add(&quot;--json&quot;);</span>
<span class="fc" id="L223">            args.add(&quot;--verbose&quot;);</span>
<span class="fc" id="L224">            final ProcessBuilder builder = new ProcessBuilder(args);</span>
<span class="fc" id="L225">            builder.directory(folder);</span>
<span class="fc" id="L226">            LOGGER.debug(&quot;Launching: {}&quot;, args);</span>
            // Workaround 64k limitation of InputStream, redirect stdout to a file that we will read later
            // instead of reading directly stdout from Process's InputStream which is topped at 64k

<span class="fc" id="L230">            final File tmpFile = getSettings().getTempFile(&quot;yarn_audit&quot;, &quot;json&quot;);</span>
<span class="fc" id="L231">            builder.redirectOutput(tmpFile);</span>
<span class="fc" id="L232">            final Process process = builder.start();</span>
<span class="fc" id="L233">            try (ProcessReader processReader = new ProcessReader(process)) {</span>
<span class="fc" id="L234">                processReader.readAll();</span>
<span class="fc" id="L235">                final String errOutput = processReader.getError();</span>

<span class="pc bpc" id="L237" title="2 of 4 branches missed.">                if (!StringUtils.isBlank(errOutput) &amp;&amp; !EXPECTED_ERROR.equals(errOutput)) {</span>
<span class="nc" id="L238">                    LOGGER.debug(&quot;Process Error Out: {}&quot;, errOutput);</span>
<span class="nc" id="L239">                    LOGGER.debug(&quot;Process Out: {}&quot;, processReader.getOutput());</span>
                }
<span class="fc" id="L241">                final String verboseJson = FileUtils.readFileToString(tmpFile, StandardCharsets.UTF_8);</span>
<span class="fc" id="L242">                final String auditRequestJson = Arrays.stream(verboseJson.split(&quot;\n&quot;))</span>
<span class="fc" id="L243">                        .filter(line -&gt; line.contains(&quot;Audit Request&quot;))</span>
<span class="fc" id="L244">                        .findFirst().get();</span>
                String auditRequest;
<span class="fc" id="L246">                try (JsonReader reader = Json.createReader(IOUtils.toInputStream(auditRequestJson, StandardCharsets.UTF_8))) {</span>
<span class="fc" id="L247">                    final JsonObject jsonObject = reader.readObject();</span>
<span class="fc" id="L248">                    auditRequest = jsonObject.getString(&quot;data&quot;);</span>
<span class="fc" id="L249">                    auditRequest = auditRequest.substring(15);</span>
                }
<span class="fc" id="L251">                LOGGER.debug(&quot;Audit Request: {}&quot;, auditRequest);</span>

<span class="fc" id="L253">                return Json.createReader(IOUtils.toInputStream(auditRequest, StandardCharsets.UTF_8)).readObject();</span>
<span class="nc" id="L254">            } catch (InterruptedException ex) {</span>
<span class="nc" id="L255">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L256">                throw new AnalysisException(&quot;Yarn audit process was interrupted.&quot;, ex);</span>
            }
<span class="nc" id="L258">        } catch (IOException ioe) {</span>
<span class="nc" id="L259">            throw new AnalysisException(&quot;yarn audit failure; this error can be ignored if you are not analyzing projects with a yarn lockfile.&quot;, ioe);</span>
        }
    }

    /**
     * Analyzes the package and yarn lock files by extracting dependency
     * information, creating a payload to submit to the npm audit API,
     * submitting the payload, and returning the identified advisories.
     *
     * @param lockFile a reference to the package-lock.json
     * @param packageFile a reference to the package.json
     * @param dependency a reference to the dependency-object for the yarn.lock
     * @param dependencyMap a collection of module/version pairs; during
     * creation of the payload the dependency map is populated with the
     * module/version information.
     * @return a list of advisories
     * @throws AnalysisException thrown when there is an error creating or
     * submitting the npm audit API payload
     */
    private List&lt;Advisory&gt; analyzePackage(final File lockFile, final File packageFile,
            Dependency dependency, MultiValuedMap&lt;String, String&gt; dependencyMap)
            throws AnalysisException {
        try {
<span class="fc" id="L282">            final Boolean skipDevDependencies = getSettings().getBoolean(Settings.KEYS.ANALYZER_NODE_AUDIT_SKIPDEV, false);</span>
            // Retrieves the contents of package-lock.json from the Dependency
<span class="fc" id="L284">            final JsonObject lockJson = fetchYarnAuditJson(dependency, skipDevDependencies);</span>
            // Retrieves the contents of package-lock.json from the Dependency
<span class="fc" id="L286">            final JsonReader packageReader = Json.createReader(FileUtils.openInputStream(packageFile));</span>
<span class="fc" id="L287">            final JsonObject packageJson = packageReader.readObject();</span>

            // Modify the payload to meet the NPM Audit API requirements
<span class="fc" id="L290">            final JsonObject payload = NpmPayloadBuilder.build(lockJson, packageJson, dependencyMap, skipDevDependencies);</span>

            // Submits the package payload to the nsp check service
<span class="fc" id="L293">            return getSearcher().submitPackage(payload);</span>

<span class="nc" id="L295">        } catch (URLConnectionFailureException e) {</span>
<span class="nc" id="L296">            this.setEnabled(false);</span>
<span class="nc" id="L297">            throw new AnalysisException(&quot;Failed to connect to the NPM Audit API (YarnAuditAnalyzer); the analyzer &quot;</span>
                    + &quot;is being disabled and may result in false negatives.&quot;, e);
<span class="nc" id="L299">        } catch (IOException e) {</span>
<span class="nc" id="L300">            LOGGER.debug(&quot;Error reading dependency or connecting to NPM Audit API&quot;, e);</span>
<span class="nc" id="L301">            this.setEnabled(false);</span>
<span class="nc" id="L302">            throw new AnalysisException(&quot;Failed to read results from the NPM Audit API (YarnAuditAnalyzer); &quot;</span>
                    + &quot;the analyzer is being disabled and may result in false negatives.&quot;, e);
<span class="nc" id="L304">        } catch (JsonException e) {</span>
<span class="nc" id="L305">            throw new AnalysisException(String.format(&quot;Failed to parse %s file from the NPM Audit API &quot;</span>
<span class="nc" id="L306">                    + &quot;(YarnAuditAnalyzer).&quot;, lockFile.getPath()), e);</span>
<span class="nc" id="L307">        } catch (SearchException ex) {</span>
<span class="nc" id="L308">            LOGGER.error(&quot;YarnAuditAnalyzer failed on {}&quot;, dependency.getActualFilePath());</span>
<span class="nc" id="L309">            throw ex;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>
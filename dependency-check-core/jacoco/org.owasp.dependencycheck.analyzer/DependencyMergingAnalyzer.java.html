<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DependencyMergingAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dependency-Check Core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">DependencyMergingAnalyzer.java</span></div><h1>DependencyMergingAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2012 Jeremy Long. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import java.io.File;
import java.util.Set;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.EvidenceType;
import org.owasp.dependencycheck.utils.FileUtils;
import org.owasp.dependencycheck.utils.Settings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * &lt;p&gt;
 * This analyzer will merge dependencies, created from different source, into a
 * single dependency.&lt;/p&gt;
 *
 * @author Jeremy Long
 */
<span class="fc" id="L36">public class DependencyMergingAnalyzer extends AbstractDependencyComparingAnalyzer {</span>

    /**
     * The Logger.
     */
<span class="fc" id="L41">    private static final Logger LOGGER = LoggerFactory.getLogger(DependencyMergingAnalyzer.class);</span>
    /**
     * The name of the analyzer.
     */
    private static final String ANALYZER_NAME = &quot;Dependency Merging Analyzer&quot;;
    /**
     * The phase that this analyzer is intended to run in.
     */
<span class="fc" id="L49">    private static final AnalysisPhase ANALYSIS_PHASE = AnalysisPhase.POST_INFORMATION_COLLECTION;</span>

    /**
     * Returns the name of the analyzer.
     *
     * @return the name of the analyzer.
     */
    @Override
    public String getName() {
<span class="fc" id="L58">        return ANALYZER_NAME;</span>
    }

    /**
     * Returns the phase that the analyzer is intended to run in.
     *
     * @return the phase that the analyzer is intended to run in.
     */
    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L68">        return ANALYSIS_PHASE;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the setting key to determine if the analyzer is enabled.&lt;/p&gt;
     *
     * @return the key for the analyzer's enabled property
     */
    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L79">        return Settings.KEYS.ANALYZER_DEPENDENCY_MERGING_ENABLED;</span>
    }

    /**
     * Evaluates the dependencies
     *
     * @param dependency a dependency to compare
     * @param nextDependency a dependency to compare
     * @param dependenciesToRemove a set of dependencies that will be removed
     * @return true if a dependency is removed; otherwise false
     */
    @Override
    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected boolean evaluateDependencies(final Dependency dependency, final Dependency nextDependency, final Set&lt;Dependency&gt; dependenciesToRemove) {
        Dependency main;
        //CSOFF: InnerAssignment
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if ((main = getMainGemspecDependency(dependency, nextDependency)) != null) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (main == dependency) {</span>
<span class="nc" id="L97">                mergeDependencies(dependency, nextDependency, dependenciesToRemove);</span>
            } else {
<span class="nc" id="L99">                mergeDependencies(nextDependency, dependency, dependenciesToRemove);</span>
<span class="nc" id="L100">                return true; //since we merged into the next dependency - skip forward to the next in mainIterator</span>
            }
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        } else if ((main = getMainSwiftDependency(dependency, nextDependency)) != null) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (main == dependency) {</span>
<span class="nc" id="L104">                mergeDependencies(dependency, nextDependency, dependenciesToRemove);</span>
            } else {
<span class="nc" id="L106">                mergeDependencies(nextDependency, dependency, dependenciesToRemove);</span>
<span class="nc" id="L107">                return true; //since we merged into the next dependency - skip forward to the next in mainIterator</span>
            }
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        } else if ((main = getMainAndroidDependency(dependency, nextDependency)) != null) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (main == dependency) {</span>
<span class="nc" id="L111">                mergeDependencies(dependency, nextDependency, dependenciesToRemove);</span>
            } else {
<span class="nc" id="L113">                mergeDependencies(nextDependency, dependency, dependenciesToRemove);</span>
<span class="nc" id="L114">                return true; //since we merged into the next dependency - skip forward to the next in mainIterator</span>
            }
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        } else if ((main = getMainDotnetDependency(dependency, nextDependency)) != null) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (main == dependency) {</span>
<span class="nc" id="L118">                mergeDependencies(dependency, nextDependency, dependenciesToRemove);</span>
            } else {
<span class="nc" id="L120">                mergeDependencies(nextDependency, dependency, dependenciesToRemove);</span>
<span class="nc" id="L121">                return true; //since we merged into the next dependency - skip forward to the next in mainIterator</span>
            }
        }
        //CSON: InnerAssignment
<span class="fc" id="L125">        return false;</span>
    }

    /**
     * Adds the relatedDependency to the dependency's related dependencies.
     *
     * @param dependency the main dependency
     * @param relatedDependency a collection of dependencies to be removed from
     * the main analysis loop, this is the source of dependencies to remove
     * @param dependenciesToRemove a collection of dependencies that will be
     * removed from the main analysis loop, this function adds to this
     * collection
     */
    public static void mergeDependencies(final Dependency dependency, final Dependency relatedDependency,
            final Set&lt;Dependency&gt; dependenciesToRemove) {
<span class="fc" id="L140">        LOGGER.debug(&quot;Merging '{}' into '{}'&quot;, relatedDependency.getFilePath(), dependency.getFilePath());</span>
<span class="fc" id="L141">        dependency.addRelatedDependency(relatedDependency);</span>
<span class="fc" id="L142">        relatedDependency.getEvidence(EvidenceType.VENDOR).forEach((e) -&gt; dependency.addEvidence(EvidenceType.VENDOR, e));</span>
<span class="fc" id="L143">        relatedDependency.getEvidence(EvidenceType.PRODUCT).forEach((e) -&gt; dependency.addEvidence(EvidenceType.PRODUCT, e));</span>
<span class="fc" id="L144">        relatedDependency.getEvidence(EvidenceType.VERSION).forEach((e) -&gt; dependency.addEvidence(EvidenceType.VERSION, e));</span>

<span class="fc" id="L146">        relatedDependency.getRelatedDependencies().stream()</span>
<span class="fc" id="L147">                .peek(dependency::addRelatedDependency)</span>
<span class="pc" id="L148">                .forEach((d) -&gt; relatedDependency.removeRelatedDependencies(d));</span>
<span class="fc" id="L149">        dependency.addAllProjectReferences(relatedDependency.getProjectReferences());</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (dependenciesToRemove != null) {</span>
<span class="fc" id="L151">            dependenciesToRemove.add(relatedDependency);</span>
        }
<span class="fc" id="L153">    }</span>

    /**
     * Bundling Ruby gems that are identified from different .gemspec files but
     * denote the same package path. This happens when Ruby bundler installs an
     * application's dependencies by running &quot;bundle install&quot;.
     *
     * @param dependency1 dependency to compare
     * @param dependency2 dependency to compare
     * @return true if the the dependencies being analyzed appear to be the
     * same; otherwise false
     */
    protected boolean isSameRubyGem(Dependency dependency1, Dependency dependency2) {
<span class="pc bpc" id="L166" title="1 of 4 branches missed.">        if (dependency1 == null || dependency2 == null</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                || !dependency1.getFileName().endsWith(&quot;.gemspec&quot;)</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">                || !dependency2.getFileName().endsWith(&quot;.gemspec&quot;)</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                || dependency1.getPackagePath() == null</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">                || dependency2.getPackagePath() == null) {</span>
<span class="fc" id="L171">            return false;</span>
        }
<span class="fc" id="L173">        return dependency1.getPackagePath().equalsIgnoreCase(dependency2.getPackagePath());</span>
    }

    /**
     * Ruby gems installed by &quot;bundle install&quot; can have zero or more *.gemspec
     * files, all of which have the same packagePath and should be grouped. If
     * one of these gemspec is from &amp;lt;parent&amp;gt;/specifications/*.gemspec,
     * because it is a stub with fully resolved gem meta-data created by Ruby
     * bundler, this dependency should be the main one. Otherwise, use
     * dependency2 as main.
     *
     * This method returns null if any dependency is not from *.gemspec, or the
     * two do not have the same packagePath. In this case, they should not be
     * grouped.
     *
     * @param dependency1 dependency to compare
     * @param dependency2 dependency to compare
     * @return the main dependency; or null if a gemspec is not included in the
     * analysis
     */
    protected Dependency getMainGemspecDependency(Dependency dependency1, Dependency dependency2) {
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (isSameRubyGem(dependency1, dependency2)) {</span>
<span class="fc" id="L195">            final File lFile = dependency1.getActualFile();</span>
<span class="fc" id="L196">            final File left = lFile.getParentFile();</span>
<span class="pc bpc" id="L197" title="1 of 4 branches missed.">            if (left != null &amp;&amp; left.getName().equalsIgnoreCase(&quot;specifications&quot;)) {</span>
<span class="fc" id="L198">                return dependency1;</span>
            }
<span class="fc" id="L200">            return dependency2;</span>
        }
<span class="fc" id="L202">        return null;</span>
    }

    /**
     * Bundling same swift dependencies with the same packagePath but identified
     * by different file type analyzers.
     *
     * @param dependency1 dependency to test
     * @param dependency2 dependency to test
     * @return &lt;code&gt;true&lt;/code&gt; if the dependencies appear to be the same;
     * otherwise &lt;code&gt;false&lt;/code&gt;
     */
    protected boolean isSameSwiftPackage(Dependency dependency1, Dependency dependency2) {
<span class="pc bpc" id="L215" title="1 of 4 branches missed.">        if (dependency1 == null || dependency2 == null</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                || (!dependency1.getFileName().endsWith(&quot;.podspec&quot;)</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                &amp;&amp; !dependency1.getFileName().equals(&quot;Package.swift&quot;))</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                || (!dependency2.getFileName().endsWith(&quot;.podspec&quot;)</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                &amp;&amp; !dependency2.getFileName().equals(&quot;Package.swift&quot;))</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">                || dependency1.getPackagePath() == null</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">                || dependency2.getPackagePath() == null) {</span>
<span class="fc" id="L222">            return false;</span>
        }
<span class="fc" id="L224">        return dependency1.getPackagePath().equalsIgnoreCase(dependency2.getPackagePath());</span>
    }

    /**
     * Determines which of the swift dependencies should be considered the
     * primary.
     *
     * @param dependency1 the first swift dependency to compare
     * @param dependency2 the second swift dependency to compare
     * @return the primary swift dependency
     */
    protected Dependency getMainSwiftDependency(Dependency dependency1, Dependency dependency2) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (isSameSwiftPackage(dependency1, dependency2)) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (dependency1.getFileName().endsWith(&quot;.podspec&quot;)) {</span>
<span class="fc" id="L238">                return dependency1;</span>
            }
<span class="fc" id="L240">            return dependency2;</span>
        }
<span class="fc" id="L242">        return null;</span>
    }

    /**
     * Determines which of the android dependencies should be considered the
     * primary.
     *
     * @param dependency1 the first android dependency to compare
     * @param dependency2 the second android dependency to compare
     * @return the primary swift dependency
     */
    protected Dependency getMainAndroidDependency(Dependency dependency1, Dependency dependency2) {
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">        if (dependency1.isVirtual() || dependency2.isVirtual()) {</span>
<span class="nc" id="L255">            return null;</span>
        }
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (&quot;classes.jar&quot;.equals(dependency2.getActualFile().getName())</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                &amp;&amp; &quot;aar&quot;.equals(FileUtils.getFileExtension(dependency1.getActualFile().getName()))</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                &amp;&amp; dependency2.getFileName().contains(dependency1.getActualFile().getName())) {</span>
<span class="fc" id="L260">            return dependency1;</span>
        }
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (&quot;classes.jar&quot;.equals(dependency1.getActualFile().getName())</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                &amp;&amp; &quot;aar&quot;.equals(FileUtils.getFileExtension(dependency2.getActualFile().getName()))</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                &amp;&amp; dependency1.getFileName().contains(dependency2.getActualFile().getName())) {</span>
<span class="nc" id="L265">            return dependency2;</span>
        }
<span class="fc" id="L267">        return null;</span>
    }

    /**
     * Determines which of the dotnet dependencies should be considered the
     * primary.
     *
     * @param dependency1 the first dotnet dependency to compare
     * @param dependency2 the second dotnet dependency to compare
     * @return the primary swift dependency
     */
    protected Dependency getMainDotnetDependency(Dependency dependency1, Dependency dependency2) {
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">        if (dependency1.getName() != null &amp;&amp; dependency1.getVersion() != null</span>
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">                &amp;&amp; dependency2.getName() != null &amp;&amp; dependency2.getVersion() != null</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">                &amp;&amp; (AssemblyAnalyzer.DEPENDENCY_ECOSYSTEM.equals(dependency1.getEcosystem())</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                || NugetconfAnalyzer.DEPENDENCY_ECOSYSTEM.equals(dependency1.getEcosystem()))</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">                &amp;&amp; (AssemblyAnalyzer.DEPENDENCY_ECOSYSTEM.equals(dependency2.getEcosystem())</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                || NugetconfAnalyzer.DEPENDENCY_ECOSYSTEM.equals(dependency2.getEcosystem()))) {</span>
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">            if (dependency1.getName().equals(dependency2.getName()) &amp;&amp; dependency1.getVersion().equals(dependency2.getVersion())) {</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                if (dependency2.isVirtual()) {</span>
<span class="fc" id="L287">                    return dependency2;</span>
                }
<span class="nc" id="L289">                return dependency1;</span>
            }
        }
<span class="fc" id="L292">        return null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HintAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dependency-Check Core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">HintAnalyzer.java</span></div><h1>HintAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2012 Jeremy Long. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Evidence;
import org.owasp.dependencycheck.dependency.EvidenceType;
import org.owasp.dependencycheck.exception.InitializationException;
import org.owasp.dependencycheck.utils.DownloadFailedException;
import org.owasp.dependencycheck.utils.Downloader;
import org.owasp.dependencycheck.utils.FileUtils;
import org.owasp.dependencycheck.utils.ResourceNotFoundException;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.utils.TooManyRequestsException;
import org.owasp.dependencycheck.xml.hints.EvidenceMatcher;
import org.owasp.dependencycheck.xml.hints.HintParseException;
import org.owasp.dependencycheck.xml.hints.HintParser;
import org.owasp.dependencycheck.xml.hints.HintRule;
import org.owasp.dependencycheck.xml.hints.VendorDuplicatingHintRule;
import org.owasp.dependencycheck.xml.suppression.PropertyType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import javax.annotation.concurrent.ThreadSafe;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * This analyzer adds evidence to dependencies to enhance the accuracy of
 * library identification.
 *
 * @author Jeremy Long
 */
@ThreadSafe
<span class="fc" id="L60">public class HintAnalyzer extends AbstractAnalyzer {</span>

    /**
     * The Logger for use throughout the class
     */
<span class="fc" id="L65">    private static final Logger LOGGER = LoggerFactory.getLogger(HintAnalyzer.class);</span>
    /**
     * The name of the hint rule file
     */
    private static final String HINT_RULE_FILE_NAME = &quot;dependencycheck-base-hint.xml&quot;;
    /**
     * The array of hint rules.
     */
<span class="fc" id="L73">    private HintRule[] hints = null;</span>
    /**
     * The array of vendor duplicating hint rules.
     */
    private VendorDuplicatingHintRule[] vendorHints;
    /**
     * The name of the analyzer.
     */
    private static final String ANALYZER_NAME = &quot;Hint Analyzer&quot;;
    /**
     * The phase that this analyzer is intended to run in.
     */
<span class="fc" id="L85">    private static final AnalysisPhase ANALYSIS_PHASE = AnalysisPhase.POST_INFORMATION_COLLECTION2;</span>

    /**
     * Returns the name of the analyzer.
     *
     * @return the name of the analyzer.
     */
    @Override
    public String getName() {
<span class="fc" id="L94">        return ANALYZER_NAME;</span>
    }

    /**
     * Returns the phase that the analyzer is intended to run in.
     *
     * @return the phase that the analyzer is intended to run in.
     */
    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L104">        return ANALYSIS_PHASE;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the setting key to determine if the analyzer is enabled.&lt;/p&gt;
     *
     * @return the key for the analyzer's enabled property
     */
    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L115">        return Settings.KEYS.ANALYZER_HINT_ENABLED;</span>
    }

    /**
     * The prepare method does nothing for this Analyzer.
     *
     * @param engine a reference the dependency-check engine
     * @throws InitializationException thrown if there is an exception
     */
    @Override
    public void prepareAnalyzer(Engine engine) throws InitializationException {
        try {
<span class="fc" id="L127">            loadHintRules();</span>
<span class="nc" id="L128">        } catch (HintParseException ex) {</span>
<span class="nc" id="L129">            LOGGER.debug(&quot;Unable to parse hint file&quot;, ex);</span>
<span class="nc" id="L130">            throw new InitializationException(&quot;Unable to parse the hint file&quot;, ex);</span>
<span class="fc" id="L131">        }</span>
<span class="fc" id="L132">    }</span>

    /**
     * The HintAnalyzer uses knowledge about a dependency to add additional
     * information to help in identification of identifiers or vulnerabilities.
     *
     * @param dependency The dependency being analyzed
     * @param engine The scanning engine
     * @throws AnalysisException is thrown if there is an exception analyzing
     * the dependency.
     */
    @Override
    @SuppressWarnings(&quot;StringSplitter&quot;)
    protected void analyzeDependency(Dependency dependency, Engine engine) throws AnalysisException {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (HintRule hint : hints) {</span>
<span class="fc" id="L147">            boolean matchFound = false;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (EvidenceMatcher given : hint.getGivenVendor()) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                if (hasMatchingEvidence(dependency.getEvidence(EvidenceType.VENDOR), given)) {</span>
<span class="fc" id="L150">                    matchFound = true;</span>
<span class="fc" id="L151">                    break;</span>
                }
<span class="fc" id="L153">            }</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (!matchFound) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                for (EvidenceMatcher given : hint.getGivenProduct()) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                    if (hasMatchingEvidence(dependency.getEvidence(EvidenceType.PRODUCT), given)) {</span>
<span class="fc" id="L157">                        matchFound = true;</span>
<span class="fc" id="L158">                        break;</span>
                    }
<span class="fc" id="L160">                }</span>
            }
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (!matchFound) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                for (EvidenceMatcher given : hint.getGivenVersion()) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                    if (hasMatchingEvidence(dependency.getEvidence(EvidenceType.VERSION), given)) {</span>
<span class="fc" id="L165">                        matchFound = true;</span>
<span class="fc" id="L166">                        break;</span>
                    }
<span class="fc" id="L168">                }</span>
            }
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (!matchFound) {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                for (PropertyType pt : hint.getFileNames()) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">                    if (pt.matches(dependency.getFileName())) {</span>
<span class="fc" id="L173">                        matchFound = true;</span>
<span class="fc" id="L174">                        break;</span>
                    }
<span class="fc" id="L176">                }</span>
            }
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (matchFound) {</span>
<span class="fc" id="L179">                hint.getAddVendor().forEach((e) -&gt; {</span>
<span class="fc" id="L180">                    dependency.addEvidence(EvidenceType.VENDOR, e);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                    for (String weighting : e.getValue().split(&quot; &quot;)) {</span>
<span class="fc" id="L182">                        dependency.addVendorWeighting(weighting);</span>
                    }
<span class="fc" id="L184">                });</span>
<span class="fc" id="L185">                hint.getAddProduct().forEach((e) -&gt; {</span>
<span class="fc" id="L186">                    dependency.addEvidence(EvidenceType.PRODUCT, e);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                    for (String weighting : e.getValue().split(&quot; &quot;)) {</span>
<span class="fc" id="L188">                        dependency.addProductWeighting(weighting);</span>
                    }
<span class="fc" id="L190">                });</span>
<span class="pc" id="L191">                hint.getAddVersion().forEach((e) -&gt; dependency.addEvidence(EvidenceType.VERSION, e));</span>

<span class="fc" id="L193">                hint.getRemoveVendor().forEach((e) -&gt; removeMatchingEvidences(dependency, EvidenceType.VENDOR, e));</span>
<span class="fc" id="L194">                hint.getRemoveProduct().forEach((e) -&gt; removeMatchingEvidences(dependency, EvidenceType.PRODUCT, e));</span>
<span class="fc" id="L195">                hint.getRemoveVersion().forEach((e) -&gt; removeMatchingEvidences(dependency, EvidenceType.VERSION, e));</span>
            }
        }

<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (Evidence e : dependency.getEvidence(EvidenceType.VENDOR)) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (VendorDuplicatingHintRule dhr : vendorHints) {</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                if (dhr.getValue().equalsIgnoreCase(e.getValue())) {</span>
<span class="fc" id="L202">                    dependency.addEvidence(EvidenceType.VENDOR, new Evidence(e.getSource() + &quot; (hint)&quot;,</span>
<span class="fc" id="L203">                            e.getName(), dhr.getDuplicate(), e.getConfidence(), true));</span>
                }
            }
<span class="fc" id="L206">        }</span>
<span class="fc" id="L207">    }</span>

    /**
     * Determine if there is matching evidence.
     *
     * @param evidences the evidence to test
     * @param criterion the criteria for a match
     * @return true if the evidence matches, otherwise false
     */
    private boolean hasMatchingEvidence(Set&lt;Evidence&gt; evidences, EvidenceMatcher criterion) {
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (Evidence evidence : evidences) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (criterion.matches(evidence)) {</span>
<span class="fc" id="L219">                return true;</span>
            }
<span class="fc" id="L221">        }</span>
<span class="fc" id="L222">        return false;</span>
    }

    /**
     * Removes any matching evidence from the dependency.
     *
     * @param dependency the dependency to update
     * @param type the type of evidence to inspect and possibly remove
     * @param e the evidence matcher
     */
    private void removeMatchingEvidences(Dependency dependency, EvidenceType type, EvidenceMatcher e) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (Evidence evidence : dependency.getEvidence(type)) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (e.matches(evidence)) {</span>
<span class="fc" id="L235">                dependency.removeEvidence(type, evidence);</span>
            }
<span class="fc" id="L237">        }</span>
<span class="fc" id="L238">    }</span>

    /**
     * Loads the hint rules file.
     *
     * @throws HintParseException thrown if the XML cannot be parsed.
     */
    private void loadHintRules() throws HintParseException {
        final List&lt;HintRule&gt; localHints;
        final List&lt;VendorDuplicatingHintRule&gt; localVendorHints;
<span class="fc" id="L248">        final HintParser parser = new HintParser();</span>
<span class="fc" id="L249">        File file = null;</span>
<span class="fc" id="L250">        try (InputStream in = FileUtils.getResourceAsStream(HINT_RULE_FILE_NAME)) {</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (in == null) {</span>
<span class="nc" id="L252">                throw new HintParseException(&quot;Hint rules `&quot; + HINT_RULE_FILE_NAME + &quot;` could not be found&quot;);</span>
            }
<span class="fc" id="L254">            parser.parseHints(in);</span>
<span class="nc" id="L255">        } catch (SAXException | IOException ex) {</span>
<span class="nc" id="L256">            throw new HintParseException(&quot;Error parsing hints: &quot; + ex.getMessage(), ex);</span>
<span class="fc" id="L257">        }</span>
<span class="fc" id="L258">        localHints = parser.getHintRules();</span>
<span class="fc" id="L259">        localVendorHints = parser.getVendorDuplicatingHintRules();</span>

<span class="fc" id="L261">        final String filePath = getSettings().getString(Settings.KEYS.HINTS_FILE);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (filePath != null) {</span>
<span class="fc" id="L263">            boolean deleteTempFile = false;</span>
            try {
<span class="fc" id="L265">                final Pattern uriRx = Pattern.compile(&quot;^(https?|file):.*&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (uriRx.matcher(filePath).matches()) {</span>
<span class="nc" id="L267">                    deleteTempFile = true;</span>
<span class="nc" id="L268">                    file = getSettings().getTempFile(&quot;hint&quot;, &quot;xml&quot;);</span>
<span class="nc" id="L269">                    final URL url = new URL(filePath);</span>
                    try {
<span class="nc" id="L271">                        Downloader.getInstance().fetchFile(url, file, false);</span>
<span class="nc" id="L272">                    } catch (DownloadFailedException ex) {</span>
                        try {
<span class="nc" id="L274">                            Thread.sleep(500);</span>
<span class="nc" id="L275">                            Downloader.getInstance().fetchFile(url, file, true);</span>
<span class="nc" id="L276">                        } catch (TooManyRequestsException ex1) {</span>
<span class="nc" id="L277">                            throw new HintParseException(&quot;Unable to download hint file `&quot; + file + &quot;`; received 429 - too many requests&quot;, ex1);</span>
<span class="nc" id="L278">                        } catch (ResourceNotFoundException ex1) {</span>
<span class="nc" id="L279">                            throw new HintParseException(&quot;Unable to download hint file `&quot; + file + &quot;`; received 404 - resource not found&quot;, ex1);</span>
<span class="nc" id="L280">                        } catch (InterruptedException ex1) {</span>
<span class="nc" id="L281">                            Thread.currentThread().interrupt();</span>
<span class="nc" id="L282">                            throw new HintParseException(&quot;Unable to download hint file `&quot; + file + &quot;`&quot;, ex1);</span>
<span class="nc" id="L283">                        }</span>
<span class="nc" id="L284">                    } catch (TooManyRequestsException ex) {</span>
<span class="nc" id="L285">                        throw new HintParseException(&quot;Unable to download hint file `&quot; + file + &quot;`; received 429 - too many requests&quot;, ex);</span>
<span class="nc" id="L286">                    } catch (ResourceNotFoundException ex) {</span>
<span class="nc" id="L287">                        throw new HintParseException(&quot;Unable to download hint file `&quot; + file + &quot;`; received 404 - resource not found&quot;, ex);</span>
<span class="nc" id="L288">                    }</span>
<span class="nc" id="L289">                } else {</span>
<span class="fc" id="L290">                    file = new File(filePath);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                    if (!file.exists()) {</span>
<span class="nc" id="L292">                        try (InputStream fromClasspath = FileUtils.getResourceAsStream(filePath)) {</span>
<span class="nc" id="L293">                            deleteTempFile = true;</span>
<span class="nc" id="L294">                            file = getSettings().getTempFile(&quot;hint&quot;, &quot;xml&quot;);</span>
<span class="nc" id="L295">                            Files.copy(fromClasspath, file.toPath());</span>
<span class="nc" id="L296">                        } catch (IOException ex) {</span>
<span class="nc" id="L297">                            throw new HintParseException(&quot;Unable to locate hints file in classpath&quot;, ex);</span>
<span class="nc" id="L298">                        }</span>
                    }
                }

<span class="pc bpc" id="L302" title="1 of 2 branches missed.">                if (file == null) {</span>
<span class="nc" id="L303">                    throw new HintParseException(&quot;Unable to locate hints file:&quot; + filePath);</span>
                } else {
                    try {
<span class="fc" id="L306">                        parser.parseHints(file);</span>
<span class="pc bpc" id="L307" title="2 of 4 branches missed.">                        if (parser.getHintRules() != null &amp;&amp; !parser.getHintRules().isEmpty()) {</span>
<span class="fc" id="L308">                            localHints.addAll(parser.getHintRules());</span>
                        }
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">                        if (parser.getVendorDuplicatingHintRules() != null &amp;&amp; !parser.getVendorDuplicatingHintRules().isEmpty()) {</span>
<span class="nc" id="L311">                            localVendorHints.addAll(parser.getVendorDuplicatingHintRules());</span>
                        }
<span class="nc" id="L313">                    } catch (HintParseException ex) {</span>
<span class="nc" id="L314">                        LOGGER.warn(&quot;Unable to parse hint rule xml file '{}'&quot;, file.getPath());</span>
<span class="nc" id="L315">                        LOGGER.warn(ex.getMessage());</span>
<span class="nc" id="L316">                        LOGGER.debug(&quot;&quot;, ex);</span>
<span class="nc" id="L317">                        throw ex;</span>
<span class="fc" id="L318">                    }</span>
                }
<span class="nc" id="L320">            } catch (DownloadFailedException ex) {</span>
<span class="nc" id="L321">                throw new HintParseException(&quot;Unable to fetch the configured hint file&quot;, ex);</span>
<span class="nc" id="L322">            } catch (MalformedURLException ex) {</span>
<span class="nc" id="L323">                throw new HintParseException(&quot;Configured hint file has an invalid URL&quot;, ex);</span>
<span class="nc" id="L324">            } catch (IOException ex) {</span>
<span class="nc" id="L325">                throw new HintParseException(&quot;Unable to create temp file for hints&quot;, ex);</span>
            } finally {
<span class="pc bpc" id="L327" title="3 of 4 branches missed.">                if (deleteTempFile &amp;&amp; file != null) {</span>
<span class="nc" id="L328">                    FileUtils.delete(file);</span>
                }
            }
        }
<span class="fc" id="L332">        hints = localHints.toArray(new HintRule[0]);</span>
<span class="fc" id="L333">        vendorHints = localVendorHints.toArray(new VendorDuplicatingHintRule[0]);</span>
<span class="fc" id="L334">        LOGGER.debug(&quot;{} hint rules were loaded.&quot;, hints.length);</span>
<span class="fc" id="L335">        LOGGER.debug(&quot;{} duplicating hint rules were loaded.&quot;, vendorHints.length);</span>
<span class="fc" id="L336">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PnpmAuditAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dependency-Check Core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">PnpmAuditAnalyzer.java</span></div><h1>PnpmAuditAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-ant.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2021 The OWASP Foundation. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.json.JSONException;
import org.json.JSONObject;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.analyzer.exception.SearchException;
import org.owasp.dependencycheck.analyzer.exception.UnexpectedAnalysisException;
import org.owasp.dependencycheck.data.nodeaudit.Advisory;
import org.owasp.dependencycheck.data.nodeaudit.NpmAuditParser;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.exception.InitializationException;
import org.owasp.dependencycheck.utils.FileFilterBuilder;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.utils.processing.ProcessReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.parsers.cpe.exceptions.CpeValidationException;

import javax.annotation.concurrent.ThreadSafe;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;

@ThreadSafe
<span class="fc" id="L51">public class PnpmAuditAnalyzer extends AbstractNpmAnalyzer {</span>

    /**
     * The logger.
     */
<span class="fc" id="L56">    private static final Logger LOGGER = LoggerFactory.getLogger(PnpmAuditAnalyzer.class);</span>

    /**
     * The file name to scan.
     */
    public static final String PNPM_PACKAGE_LOCK = &quot;pnpm-lock.yaml&quot;;

    /**
     * Filter that detects files named &quot;pnpm-lock.yaml&quot;
     */
<span class="fc" id="L66">    private static final FileFilter LOCK_FILE_FILTER = FileFilterBuilder.newInstance()</span>
<span class="fc" id="L67">            .addFilenames(PNPM_PACKAGE_LOCK).build();</span>

    /**
     * The path to the `pnpm` executable.
     */
    private String pnpmPath;

    /**
     * Analyzes the pnpm lock file to determine vulnerable dependencies. Uses
     * pnpm audit --json to vulnerabilities report from NPM API.
     *
     * @param dependency the pnpm lock file
     * @param engine the analysis engine
     * @throws AnalysisException thrown if there is an error analyzing the file
     */
    @Override
    protected void analyzeDependency(Dependency dependency, Engine engine) throws AnalysisException {
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (dependency.getDisplayFileName().equals(dependency.getFileName())) {</span>
<span class="nc" id="L85">            engine.removeDependency(dependency);</span>
        }
<span class="nc" id="L87">        final File packageLock = dependency.getActualFile();</span>
<span class="nc bnc" id="L88" title="All 6 branches missed.">        if (!packageLock.isFile() || packageLock.length() == 0 || !shouldProcess(packageLock)) {</span>
<span class="nc" id="L89">            return;</span>
        }
        final List&lt;Advisory&gt; advisories;
<span class="nc" id="L92">        final MultiValuedMap&lt;String, String&gt; dependencyMap = new HashSetValuedHashMap&lt;&gt;();</span>
<span class="nc" id="L93">        advisories = analyzePackage(packageLock, dependency);</span>
        try {
<span class="nc" id="L95">            processResults(advisories, engine, dependency, dependencyMap);</span>
<span class="nc" id="L96">        } catch (CpeValidationException ex) {</span>
<span class="nc" id="L97">            throw new UnexpectedAnalysisException(ex);</span>
<span class="nc" id="L98">        }</span>
<span class="nc" id="L99">    }</span>

    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L103">        return Settings.KEYS.ANALYZER_PNPM_AUDIT_ENABLED;</span>
    }

    @Override
    protected FileFilter getFileFilter() {
<span class="fc" id="L108">        return LOCK_FILE_FILTER;</span>
    }

    @Override
    public String getName() {
<span class="fc" id="L113">        return &quot;Pnpm Audit Analyzer&quot;;</span>
    }

    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L118">        return AnalysisPhase.FINDING_ANALYSIS;</span>
    }

    /**
     * Initializes the analyzer once before any analysis is performed.
     *
     * @param engine a reference to the dependency-check engine
     * @throws InitializationException if there's an error during initialization
     */
    @Override
    protected void prepareFileTypeAnalyzer(Engine engine) throws InitializationException {
<span class="fc" id="L129">        super.prepareFileTypeAnalyzer(engine);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (!isEnabled()) {</span>
<span class="nc" id="L131">            LOGGER.debug(&quot;{} Analyzer is disabled skipping pnpm executable check&quot;, getName());</span>
<span class="nc" id="L132">            return;</span>
        }
<span class="fc" id="L134">        final List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L135">        args.add(getPnpm());</span>
<span class="fc" id="L136">        args.add(&quot;--help&quot;);</span>
<span class="fc" id="L137">        final ProcessBuilder builder = new ProcessBuilder(args);</span>
<span class="fc" id="L138">        LOGGER.debug(&quot;Launching: {}&quot;, args);</span>
        try {
<span class="fc" id="L140">            final Process process = builder.start();</span>
<span class="fc" id="L141">            try (ProcessReader processReader = new ProcessReader(process)) {</span>
<span class="fc" id="L142">                processReader.readAll();</span>
<span class="fc" id="L143">                final int exitValue = process.waitFor();</span>
<span class="fc" id="L144">                final int expectedExitValue = 0;</span>
<span class="fc" id="L145">                final int executableNotFoundExitValue = 127;</span>
<span class="pc bpc" id="L146" title="2 of 3 branches missed.">                switch (exitValue) {</span>
                    case expectedExitValue:
<span class="fc" id="L148">                        LOGGER.debug(&quot;{} is enabled.&quot;, getName());</span>
<span class="fc" id="L149">                        break;</span>
                    case executableNotFoundExitValue:
<span class="nc" id="L151">                        this.setEnabled(false);</span>
<span class="nc" id="L152">                        LOGGER.warn(&quot;The {} has been disabled. Pnpm executable was not found.&quot;, getName());</span>
                    default:
<span class="nc" id="L154">                        this.setEnabled(false);</span>
<span class="nc" id="L155">                        LOGGER.warn(&quot;The {} has been disabled. Pnpm executable was not found.&quot;, getName());</span>
                }
            }
<span class="nc" id="L158">        } catch (Exception ex) {</span>
<span class="nc" id="L159">            this.setEnabled(false);</span>
<span class="nc" id="L160">            LOGGER.debug(&quot;The {} has been disabled. Pnpm executable was not found.&quot;, ex);</span>
<span class="nc" id="L161">            LOGGER.warn(&quot;The {} has been disabled. Pnpm executable was not found.&quot;, getName());</span>
<span class="nc" id="L162">            throw new InitializationException(&quot;Unable to read pnpm audit output.&quot;, ex);</span>
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">    }</span>

    /**
     * Attempts to determine the path to `pnpm`.
     *
     * @return the path to `pnpm`
     */
    private String getPnpm() {
        final String value;
<span class="fc" id="L173">        synchronized (this) {</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (pnpmPath == null) {</span>
<span class="fc" id="L175">                final String path = getSettings().getString(Settings.KEYS.ANALYZER_PNPM_PATH);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                if (path == null) {</span>
<span class="fc" id="L177">                    pnpmPath = &quot;pnpm&quot;;</span>
                } else {
<span class="nc" id="L179">                    final File pnpmFile = new File(path);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    if (pnpmFile.isFile()) {</span>
<span class="nc" id="L181">                        pnpmPath = pnpmFile.getAbsolutePath();</span>
                    } else {
<span class="nc" id="L183">                        LOGGER.warn(&quot;Provided path to `pnpm` executable is invalid.&quot;);</span>
<span class="nc" id="L184">                        pnpmPath = &quot;pnpm&quot;;</span>
                    }
                }
            }
<span class="fc" id="L188">            value = pnpmPath;</span>
<span class="fc" id="L189">        }</span>
<span class="fc" id="L190">        return value;</span>
    }

    private JSONObject fetchPnpmAuditJson(Dependency dependency, boolean skipDevDependencies) throws AnalysisException {
<span class="nc" id="L194">        final File folder = dependency.getActualFile().getParentFile();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (!folder.isDirectory()) {</span>
<span class="nc" id="L196">            throw new AnalysisException(String.format(&quot;%s should have been a directory.&quot;, folder.getAbsolutePath()));</span>
        }
        try {
<span class="nc" id="L199">            final List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L201">            args.add(getPnpm());</span>
<span class="nc" id="L202">            args.add(&quot;audit&quot;);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (skipDevDependencies) {</span>
<span class="nc" id="L204">                args.add(&quot;--prod&quot;);</span>
            }
            // pnpm audit returns a json compliant with NpmAuditParser
<span class="nc" id="L207">            args.add(&quot;--json&quot;);</span>
            // ensure we are using the right registry despite .npmrc
<span class="nc" id="L209">            args.add(&quot;--registry&quot;);</span>
<span class="nc" id="L210">            args.add(&quot;https://registry.npmjs.org/&quot;);</span>
<span class="nc" id="L211">            final ProcessBuilder builder = new ProcessBuilder(args);</span>
<span class="nc" id="L212">            builder.directory(folder);</span>
            // Workaround 64k limitation of InputStream, redirect stdout to a file that we will read later
            // instead of reading directly stdout from Process's InputStream which is topped at 64k
<span class="nc" id="L215">            final File tmpFile = File.createTempFile(&quot;pnpm_audit&quot;, null);</span>
<span class="nc" id="L216">            builder.redirectOutput(tmpFile);</span>
<span class="nc" id="L217">            LOGGER.debug(&quot;Launching: {}&quot;, args);</span>
<span class="nc" id="L218">            final Process process = builder.start();</span>
<span class="nc" id="L219">            try (ProcessReader processReader = new ProcessReader(process)) {</span>
<span class="nc" id="L220">                processReader.readAll();</span>
<span class="nc" id="L221">                final String errOutput = processReader.getError();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if (!StringUtils.isBlank(errOutput)) {</span>
<span class="nc" id="L223">                    LOGGER.error(&quot;Process error output: {}&quot;, errOutput);</span>
                }
<span class="nc" id="L225">                String verboseJson = FileUtils.readFileToString(tmpFile, StandardCharsets.UTF_8);</span>
                // Workaround implicit creation of .pnpm-debug.log, see https://github.com/pnpm/pnpm/issues/3832
                // affects usage of docker container to analyze mounted directories without privileges
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (verboseJson.contains(&quot;EACCES: permission denied, open 'node_modules/.pnpm-debug.log'&quot;)) {</span>
<span class="nc" id="L229">                    verboseJson = verboseJson.substring(0, verboseJson.indexOf(&quot;EACCES: permission denied, open 'node_modules/.pnpm-debug.log'&quot;));</span>
                }
<span class="nc" id="L231">                LOGGER.debug(&quot;Audit report: {}&quot;, verboseJson);</span>
<span class="nc" id="L232">                return new JSONObject(verboseJson);</span>
<span class="nc" id="L233">            } catch (InterruptedException ex) {</span>
<span class="nc" id="L234">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L235">                throw new AnalysisException(&quot;Pnpm audit process was interrupted.&quot;, ex);</span>
<span class="nc" id="L236">            } catch (JSONException e) {</span>
<span class="nc" id="L237">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L238">                throw new AnalysisException(&quot;Pnpm audit returned an invalid response.&quot;, e);</span>
            } finally {
<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (!tmpFile.delete()) {</span>
<span class="nc" id="L241">                    LOGGER.debug(&quot;Unable to delete temp file: {}&quot;, tmpFile.toString());</span>
                }
            }
<span class="nc" id="L244">        } catch (IOException ioe) {</span>
<span class="nc" id="L245">            throw new AnalysisException(&quot;pnpm audit failure; this error can be ignored if you are not analyzing projects with a pnpm lockfile.&quot;, ioe);</span>
        }
    }

    /**
     * Analyzes the package and pnpm lock files by extracting dependency
     * information, creating a payload to submit to the npm audit API,
     * submitting the payload, and returning the identified advisories.
     *
     * @param lockFile a reference to the pnpm-lock.yaml
     * @param dependency a reference to the dependency-object for the
     * pnpm-lock.yaml
     * @return a list of advisories
     * @throws AnalysisException thrown when there is an error creating or
     * submitting the npm audit API payload
     */
    private List&lt;Advisory&gt; analyzePackage(final File lockFile,
            Dependency dependency)
            throws AnalysisException {
        try {
<span class="nc" id="L265">            final Boolean skipDevDependencies = getSettings().getBoolean(Settings.KEYS.ANALYZER_NODE_AUDIT_SKIPDEV, false);</span>

            // Use pnpm directly to fetch audit.json
            // Retrieves the contents of package-lock.json from the Dependency
<span class="nc" id="L269">            final JSONObject auditJson = fetchPnpmAuditJson(dependency, skipDevDependencies);</span>
            // Submits the package payload to the nsp check service
<span class="nc" id="L271">            return getAuditParser().parse(auditJson);</span>

<span class="nc" id="L273">        } catch (JSONException e) {</span>
<span class="nc" id="L274">            throw new AnalysisException(String.format(&quot;Failed to parse %s file from the NPM Audit API &quot;</span>
<span class="nc" id="L275">                    + &quot;(PnpmAuditAnalyzer).&quot;, lockFile.getPath()), e);</span>
<span class="nc" id="L276">        } catch (SearchException ex) {</span>
<span class="nc" id="L277">            LOGGER.error(&quot;PnpmAuditAnalyzer failed on {}&quot;, dependency.getActualFilePath());</span>
<span class="nc" id="L278">            throw ex;</span>
        }
    }

    @NotNull
    private NpmAuditParser getAuditParser() {
<span class="nc" id="L284">        return new NpmAuditParser();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
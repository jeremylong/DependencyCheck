<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractMemoryIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dependency-Check Core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.data.cpe</a> &gt; <span class="el_source">AbstractMemoryIndex.java</span></div><h1>AbstractMemoryIndex.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2013 Jeremy Long. All Rights Reserved.
 */
package org.owasp.dependencycheck.data.cpe;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.concurrent.ThreadSafe;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.core.KeywordAnalyzer;
import org.apache.lucene.analysis.miscellaneous.PerFieldAnalyzerWrapper;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.MMapDirectory;
import org.owasp.dependencycheck.data.lucene.SearchFieldAnalyzer;
import org.owasp.dependencycheck.data.nvdcve.DatabaseException;
import org.owasp.dependencycheck.utils.Pair;
import org.owasp.dependencycheck.utils.Settings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * &lt;p&gt;
 * An in memory Lucene index that contains the vendor/product combinations from
 * the CPE (application) identifiers within the NVD CVE data.&lt;/p&gt;
 *
 * This is the last remaining singleton in dependency-check-core; The use of
 * this singleton - while it may not technically be thread-safe (one database
 * used to build this index may not have the same entries as another) the risk
 * of this is currently believed to be small. As this memory index consumes a
 * large amount of memory we will remain using the singleton pattern for now.
 *
 * @author Jeremy Long
 */
@ThreadSafe
<span class="fc" id="L68">public abstract class AbstractMemoryIndex implements MemoryIndex {</span>

    /**
     * The logger.
     */
<span class="fc" id="L73">    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractMemoryIndex.class);</span>
    /**
     * The in memory Lucene index.
     */
    private MMapDirectory index;
    /**
     * The Lucene IndexReader.
     */
    private IndexReader indexReader;
    /**
     * The Lucene IndexSearcher.
     */
    private IndexSearcher indexSearcher;
    /**
     * The Lucene Analyzer used for Searching.
     */
    private Analyzer searchingAnalyzer;
    /**
     * The Lucene QueryParser used for Searching.
     */
    private QueryParser queryParser;
    /**
     * The product field analyzer.
     */
    private SearchFieldAnalyzer productFieldAnalyzer;
    /**
     * The vendor field analyzer.
     */
    private SearchFieldAnalyzer vendorFieldAnalyzer;
    /**
     * Track the number of current users of the Lucene index; used to track it
     * it is okay to actually close the index.
     */
<span class="fc" id="L106">    private final AtomicInteger usageCount = new AtomicInteger(0);</span>

    /**
     * Returns a reference to the instance.
     *
     * @return a reference to the instance
     */
    protected abstract AbstractMemoryIndex instance();

    /**
     * Creates and loads data into an in memory index.
     *
     * @param data the CPE data
     * @param settings a reference to the dependency-check settings
     * @throws IndexException thrown if there is an error creating the index
     */
    @Override
    public synchronized void open(Set&lt;Pair&lt;String, String&gt;&gt; data, Settings settings) throws IndexException {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (instance().usageCount.addAndGet(1) == 1) {</span>
            try {
<span class="fc" id="L126">                final File temp = settings.getTempDirectory();</span>
<span class="fc" id="L127">                index = new MMapDirectory(temp.toPath());</span>
<span class="fc" id="L128">                buildIndex(data);</span>

<span class="fc" id="L130">                indexReader = DirectoryReader.open(index);</span>
<span class="nc" id="L131">            } catch (IOException ex) {</span>
<span class="nc" id="L132">                throw new IndexException(ex);</span>
<span class="fc" id="L133">            }</span>
<span class="fc" id="L134">            indexSearcher = new IndexSearcher(indexReader);</span>
<span class="fc" id="L135">            searchingAnalyzer = createSearchingAnalyzer();</span>
<span class="fc" id="L136">            queryParser = new QueryParser(Fields.DOCUMENT_KEY, searchingAnalyzer);</span>
        }
<span class="fc" id="L138">    }</span>

    /**
     * returns whether or not the index is open.
     *
     * @return whether or not the index is open
     */
    public synchronized boolean isOpen() {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        return instance().usageCount.get() &gt; 0;</span>
    }

    /**
     * Creates an Analyzer for searching the CPE Index.
     *
     * @return the CPE Analyzer.
     */
    private Analyzer createSearchingAnalyzer() {
<span class="fc" id="L155">        final Map&lt;String, Analyzer&gt; fieldAnalyzers = new HashMap&lt;&gt;();</span>
<span class="fc" id="L156">        fieldAnalyzers.put(Fields.DOCUMENT_KEY, new KeywordAnalyzer());</span>
<span class="fc" id="L157">        productFieldAnalyzer = new SearchFieldAnalyzer();</span>
<span class="fc" id="L158">        vendorFieldAnalyzer = new SearchFieldAnalyzer();</span>
<span class="fc" id="L159">        fieldAnalyzers.put(Fields.PRODUCT, productFieldAnalyzer);</span>
<span class="fc" id="L160">        fieldAnalyzers.put(Fields.VENDOR, vendorFieldAnalyzer);</span>

<span class="fc" id="L162">        return new PerFieldAnalyzerWrapper(new KeywordAnalyzer(), fieldAnalyzers);</span>
    }

    /**
     * Closes the CPE Index.
     */
    @Override
    public synchronized void close() {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (instance().usageCount.addAndGet(-1) == 0) {</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (searchingAnalyzer != null) {</span>
<span class="fc" id="L172">                searchingAnalyzer.close();</span>
<span class="fc" id="L173">                searchingAnalyzer = null;</span>
            }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (indexReader != null) {</span>
                try {
<span class="fc" id="L177">                    indexReader.close();</span>
<span class="nc" id="L178">                } catch (IOException ex) {</span>
<span class="nc" id="L179">                    LOGGER.trace(&quot;&quot;, ex);</span>
<span class="fc" id="L180">                }</span>
<span class="fc" id="L181">                indexReader = null;</span>
            }
<span class="fc" id="L183">            queryParser = null;</span>
<span class="fc" id="L184">            indexSearcher = null;</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (index != null) {</span>
                try {
<span class="fc" id="L187">                    index.close();</span>
<span class="nc" id="L188">                } catch (IOException ex) {</span>
<span class="nc" id="L189">                    LOGGER.trace(&quot;&quot;, ex);</span>
<span class="fc" id="L190">                }</span>
<span class="fc" id="L191">                index = null;</span>
            }
        }
<span class="fc" id="L194">    }</span>

    /**
     * Builds the CPE Lucene Index based off of the data within the CveDB.
     *
     * @param data the CPE data
     * @throws IndexException thrown if there is an issue creating the index
     */
    private void buildIndex(Set&lt;Pair&lt;String, String&gt;&gt; data) throws IndexException {
<span class="fc" id="L203">        try (Analyzer analyzer = createSearchingAnalyzer();</span>
<span class="fc" id="L204">                IndexWriter indexWriter = new IndexWriter(index,</span>
                        new IndexWriterConfig(analyzer))) {

<span class="fc" id="L207">            final FieldType ft = new FieldType(TextField.TYPE_STORED);</span>
            //ignore term frequency
<span class="fc" id="L209">            ft.setIndexOptions(IndexOptions.DOCS);</span>
            //ignore field length normalization
<span class="fc" id="L211">            ft.setOmitNorms(true);</span>
            // Tip: reuse the Document and Fields for performance...
            // See &quot;Re-use Document and Field instances&quot; from
            // http://wiki.apache.org/lucene-java/ImproveIndexingSpeed
<span class="fc" id="L215">            final Document doc = new Document();</span>
<span class="fc" id="L216">            final Field v = new Field(Fields.VENDOR, Fields.VENDOR, ft);</span>
<span class="fc" id="L217">            final Field p = new Field(Fields.PRODUCT, Fields.PRODUCT, ft);</span>

<span class="fc" id="L219">            doc.add(v);</span>
<span class="fc" id="L220">            doc.add(p);</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">            for (Pair&lt;String, String&gt; pair : data) {</span>
<span class="pc bpc" id="L223" title="2 of 4 branches missed.">                if (pair.getLeft() != null &amp;&amp; pair.getRight() != null) {</span>
<span class="fc" id="L224">                    v.setStringValue(pair.getLeft());</span>
<span class="fc" id="L225">                    p.setStringValue(pair.getRight());</span>
<span class="fc" id="L226">                    indexWriter.addDocument(doc);</span>
<span class="fc" id="L227">                    resetAnalyzers();</span>
                }
<span class="fc" id="L229">            }</span>
<span class="fc" id="L230">            indexWriter.commit();</span>

<span class="nc" id="L232">        } catch (DatabaseException ex) {</span>
<span class="nc" id="L233">            LOGGER.debug(&quot;&quot;, ex);</span>
<span class="nc" id="L234">            throw new IndexException(&quot;Error reading CPE data&quot;, ex);</span>
<span class="nc" id="L235">        } catch (IOException ex) {</span>
<span class="nc" id="L236">            throw new IndexException(&quot;Unable to close an in-memory index&quot;, ex);</span>
<span class="fc" id="L237">        }</span>
<span class="fc" id="L238">    }</span>

    /**
     * Searches the index using the given search string.
     *
     * @param searchString the query text
     * @param maxQueryResults the maximum number of documents to return
     * @return the TopDocs found by the search
     * @throws ParseException thrown when the searchString is invalid
     * @throws IndexException thrown when there is an internal error resetting
     * the search analyzer
     * @throws IOException is thrown if there is an issue with the underlying
     * Index
     */
    @Override
    public synchronized TopDocs search(String searchString, int maxQueryResults) throws ParseException, IndexException, IOException {
<span class="fc" id="L254">        final Query query = parseQuery(searchString);</span>
<span class="fc" id="L255">        return search(query, maxQueryResults);</span>
    }

    /**
     * Parses the given string into a Lucene Query.
     *
     * @param searchString the search text
     * @return the Query object
     * @throws ParseException thrown if the search text cannot be parsed
     * @throws IndexException thrown if there is an error resetting the
     * analyzers
     */
    @Override
    public synchronized Query parseQuery(String searchString) throws ParseException, IndexException {
<span class="pc bpc" id="L269" title="2 of 4 branches missed.">        if (searchString == null || searchString.trim().isEmpty()</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                || &quot;product:() AND vendor:()&quot;.equals(searchString)) {</span>
<span class="nc" id="L271">            throw new ParseException(&quot;Query is null or empty&quot;);</span>
        }
<span class="fc" id="L273">        LOGGER.debug(searchString);</span>

        Query query;
        try {
<span class="fc" id="L277">            query = queryParser.parse(searchString);</span>
<span class="nc" id="L278">        } catch (BooleanQuery.TooManyClauses ex) {</span>
<span class="nc" id="L279">            BooleanQuery.setMaxClauseCount(Integer.MAX_VALUE);</span>
<span class="nc" id="L280">            query = queryParser.parse(searchString);</span>
<span class="nc" id="L281">        } catch (ParseException ex) {</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">            if (ex.getMessage() != null &amp;&amp; ex.getMessage().contains(&quot;too many boolean clauses&quot;)) {</span>
<span class="nc" id="L283">                BooleanQuery.setMaxClauseCount(Integer.MAX_VALUE);</span>
<span class="nc" id="L284">                query = queryParser.parse(searchString);</span>
            } else {
<span class="nc" id="L286">                LOGGER.debug(&quot;Parse Excepction&quot;, ex);</span>
<span class="nc" id="L287">                throw ex;</span>
            }
<span class="pc" id="L289">        }</span>
        try {
<span class="fc" id="L291">            resetAnalyzers();</span>
<span class="nc" id="L292">        } catch (IOException ex) {</span>
<span class="nc" id="L293">            throw new IndexException(&quot;Unable to reset the analyzer after parsing&quot;, ex);</span>
<span class="fc" id="L294">        }</span>
<span class="fc" id="L295">        return query;</span>
    }

    /**
     * Searches the index using the given query.
     *
     * @param query the query used to search the index
     * @param maxQueryResults the max number of results to return
     * @return the TopDocs found be the query
     * @throws CorruptIndexException thrown if the Index is corrupt
     * @throws IOException thrown if there is an IOException
     */
    @Override
    public synchronized TopDocs search(Query query, int maxQueryResults) throws CorruptIndexException, IOException {
<span class="fc" id="L309">        return indexSearcher.search(query, maxQueryResults);</span>
    }

    /**
     * Retrieves a document from the Index.
     *
     * @param documentId the id of the document to retrieve
     * @return the Document
     * @throws IOException thrown if there is an IOException
     */
    @Override
    public synchronized Document getDocument(int documentId) throws IOException {
<span class="fc" id="L321">        return indexSearcher.doc(documentId);</span>
    }

    /**
     * Returns the number of CPE entries stored in the index.
     *
     * @return the number of CPE entries stored in the index
     */
    public synchronized int numDocs() {
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (indexReader == null) {</span>
<span class="nc" id="L331">            return -1;</span>
        }
<span class="fc" id="L333">        return indexReader.numDocs();</span>
    }

    /**
     * Method to explain queries matches.
     *
     * @param query the query used
     * @param doc the document matched
     * @return the explanation
     * @throws IOException thrown if there is an index error
     */
    public synchronized String explain(Query query, int doc) throws IOException {
<span class="nc" id="L345">        return indexSearcher.explain(query, doc).toString();</span>
    }

    /**
     * Common method to reset the searching analyzers.
     *
     * @throws IOException thrown if there is an index error
     */
    protected synchronized void resetAnalyzers() throws IOException {
<span class="fc" id="L354">        productFieldAnalyzer.reset();</span>
<span class="fc" id="L355">        vendorFieldAnalyzer.reset();</span>
<span class="fc" id="L356">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>